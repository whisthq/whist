# Shell for this makefile
SHELL := /bin/bash

# Go command (configurable for testing different installations, etc.)
GOCMD        = go

# Build parameters
BUILD_FOLDER = build
DOCS_FOLDER  = $(BUILD_FOLDER)/docs
ROOT_HOMEDIR := $(shell sudo --preserve-env=PATH sh -c 'cd ~ && pwd')

# Git parameters
GIT_COMMIT := $(shell git rev-list -1 HEAD)
GIT_BRANCH := $(shell git rev-parse --abbrev-ref HEAD)

# Continuous Integration parameters
CI ?= false
ifeq ($(CI),true)
HEROKU_USER ?= $(shell heroku auth:whoami)
HEROKU_APIKEY ?= $(shell heroku auth:token | tail -1)
HEROKU_APP_NAME_OVERRIDE ?=
endif

.default: build
.DEFAULT_GOAL := build

# Check that the required environment variables for building as part of our
# continuous integration/deployment pipeline on GitHub Actions are set properly.
checkCI:
	$(info building in $(BUILD_FOLDER) with CI set to $(CI)...)
ifeq ($(CI),true)
# We're building on GitHub Actions, so we need to require non-trivial secrets
	$(info CI is true)
ifeq ($(origin HEROKU_USER),file)
	$(error "HEROKU_USER is not set, but CI is true")
endif
ifeq ($(HEROKU_USER),)
	$(error "HEROKU_USER is empty, but CI is true")
endif
ifeq ($(origin HEROKU_APIKEY),file)
	$(error "HEROKU_APIKEY is not set, but CI is true")
endif
ifeq ($(HEROKU_APIKEY),)
	$(error "HEROKU_APIKEY is empty, but CI is true")
endif
else
	$(info CI is false)
endif

queries_sql_files := $(wildcard ./host-service/dbdriver/queries/*.sql)
queries_sql_go_files := $(patsubst %.sql,%.sql.go,$(queries_sql_files))
$(queries_sql_go_files): $(queries_sql_files) ../database/schema.sql go.mod
	$(GOCMD) install github.com/jschaf/pggen/cmd/pggen@latest
	touch $(CURDIR)/host-service/dbdriver/queries/temp.sql.go
	find $(CURDIR)/host-service/dbdriver/queries -type f -name "*.sql.go" | xargs rm
	$(GOCMD) generate ./host-service/dbdriver/...

build: checkCI $(queries_sql_go_files)
	$(GOCMD) mod tidy -v
	$(GOCMD) build -ldflags "\
		-X 'github.com/whisthq/whist/backend/services/metadata.gitCommit=$(GIT_COMMIT)'\
		-X 'github.com/whisthq/whist/backend/services/metadata/heroku.email=$(HEROKU_USER)'\
		-X 'github.com/whisthq/whist/backend/services/metadata/heroku.apiKey=$(HEROKU_APIKEY)'\
		-X 'github.com/whisthq/whist/backend/services/metadata/heroku.appNameOverride=$(HEROKU_APP_NAME_OVERRIDE)'\
		" -o $(BUILD_FOLDER)/ ./...

format:
	(cd ~ && $(GOCMD) install golang.org/x/tools/cmd/goimports@latest)
	goimports -l -w $$(find $(CURDIR) -name "*.go" | grep --invert-match ".sql.go" | xargs)

lint: build
	(cd ~ && $(GOCMD) install honnef.co/go/tools/cmd/staticcheck@latest)
	$(GOCMD) list ./... | xargs staticcheck

vet: build
	$(GOCMD) list ./... | grep -v /agent/ | xargs $(GOCMD) vet

test: build
	@echo "Running go tests..."

# We need to run some tests as root since the host-service init() checks for root perms.
#
# Set CI flag in test environment so we can properly skip metrics collection in CI
#
# -p 1 flag ensures that tests run in series instead of parallel
# This ensures that tests that use the file system do not conflict or race with each other
#
# Set AWS credentials to allow user config integration tests to run
	sudo env "PATH=$(PATH)" "CI=$(CI)" "AWS_ACCESS_KEY_ID=$(AWS_ACCESS_KEY_ID)" "AWS_SECRET_ACCESS_KEY=$(AWS_SECRET_ACCESS_KEY)" $(GOCMD) test -v -p 1 ./... -race -covermode=atomic -coverprofile=$(BUILD_FOLDER)/coverage.out

ifeq ($(CI),true)
	@echo "Running in CI, uploading code coverage results to Codecov..."
# Download the Codecov uploader
	curl --silent https://uploader.codecov.io/latest/linux/codecov --create-dirs --output $(BUILD_FOLDER)/codecov && chmod +x $(BUILD_FOLDER)/codecov

# Upload coverage report to Codecov
	$(BUILD_FOLDER)/codecov -t ${CODECOV_TOKEN} -c -F backend-services
	@echo "Finished uploading code coverage results to Codecov."
else
	@echo "Not running in CI, skipping code coverage upload to Codecov..."
endif

# test_local is a target that runs tests with caches and prints out a more
# human-readable result for failures. It is more suitable for local
# development. We continue to use the plain `test` target for CI.
test_local: build
	$(GOCMD) install gotest.tools/gotestsum@latest
	@echo "Running gotestsum..."
	sudo env "PATH=$(PATH)" "CI=$(CI)" "AWS_ACCESS_KEY_ID=$(AWS_ACCESS_KEY_ID)" "AWS_SECRET_ACCESS_KEY=$(AWS_SECRET_ACCESS_KEY)" gotestsum

docs:
	$(GOCMD) install github.com/johnstarich/go/gopages@master
	gopages -out="$(DOCS_FOLDER)" -base="https://docs.whist.com/backend/services/" -brand-title="Whist Backend Services" -brand-description="Autogenerated from $(shell git describe --always --match "NOT A TAG" --dirty)" -source-link="https://github.com/whisthq/whist/blob/$(GIT_BRANCH)/backend/services/{{.Path}}{{if .Line}}#L{{.Line}}{{end}}"

# Note that we build before we lint or vet, since build updates the Whist dependencies.
.NOTPARALLEL:
check: clean build vet format lint test docs
# In CI, we check for a diff to make sure that `format` didn't change
# anything. This also helps us make sure we didn't delete a `.sql` file
# without deleting the `.sql.go` file, for instance.
ifeq ($(CI),true)
	git diff --exit-code
endif
	@echo "All checks (clean, build, vet, format, lint, test, and docs) succeeded!"

clean:
	rm -rf $(BUILD_FOLDER)
# We do this to reset the host-service to a "full clean build" state.
	@touch $(CURDIR)/host-service/dbdriver/queries/temp.sql.go
	@find $(CURDIR)/host-service/dbdriver/queries -type f -name "*.sql.go" | xargs rm
	@echo "The automatically generated .sql.go files in host-service/dbdriver/queries/ have been removed. To get them back, run 'make' or use a variation of 'git reset'."

clean_modcache:
	$(GOCMD) clean -modcache

#
## Host service-specific targets
#

run_host_service: build
	$(info running $(BUILD_FOLDER)/host-service with localdev configuration...)
# We run the built binary instead of using `go run` because otherwise signal
# handling for Ctrl+C does not work. We also create the symlink below so that
# the host service can use the `ubuntu` account's aws credentials to run,
# even though it runs as root.
	sudo [ -e $(ROOT_HOMEDIR)/.aws ] || sudo ln -s -T "$(HOME)/.aws" "$(ROOT_HOMEDIR)/.aws"
	sudo --preserve-env=PATH --preserve-env=LOCALDEV_PROTOCOL_CONNECT_TIMEOUT --preserve-env=LOCALDEV_PROTOCOL_DISCONNECT_TIMEOUT APP_ENV=localdev GPU=$(GPU) $(BUILD_FOLDER)/host-service

run_host_service_localdevwithdb: build
	$(info running $(BUILD_FOLDER)/host-service with localdevwithdb configuration...)
	sudo [ -e $(ROOT_HOMEDIR)/.aws ] || sudo ln -s -T "$(HOME)/.aws" "$(ROOT_HOMEDIR)/.aws"
	sudo --preserve-env=PATH APP_ENV=localdevwithdb GPU=$(GPU) $(BUILD_FOLDER)/host-service

run_host_service_dev: build
	$(info running $(BUILD_FOLDER)/host-service with dev configuration...)
	sudo [ -e $(ROOT_HOMEDIR)/.aws ] || sudo ln -s -T "$(HOME)/.aws" "$(ROOT_HOMEDIR)/.aws"
	sudo --preserve-env=PATH APP_ENV=dev GPU=$(GPU) USE_PROD_LOGGING=0 $(BUILD_FOLDER)/host-service

#
## Scaling service-specific targets
#

run_scaling_service: build
	$(info running $(BUILD_FOLDER)/scaling-service with localdev configuration...)
	APP_ENV=localdev $(BUILD_FOLDER)/scaling-service

run_scaling_service_localdevwithdb: build
	$(info running $(BUILD_FOLDER)/scaling-service with localdevwithdb configuration...)
	APP_ENV=localdevwithdb $(BUILD_FOLDER)/scaling-service

run_scaling_service_dev: build
	$(info running $(BUILD_FOLDER)/scaling-service with dev (deployed) configuration...)
	APP_ENV=dev USE_PROD_LOGGING=0 $(BUILD_FOLDER)/scaling-service


.PHONY: checkCI build format lint vet test test_local docs check clean clean_modcache run_host_service run_host_service_localdevwithdb run_host_service_dev run_scaling_service run_scaling_service_localdevwithdb run_scaling_service_dev
