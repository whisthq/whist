# workflows/fractal-build-and-deploy.yml
#
# Fractal: Build & Deploy
# Build and deploy each of the relevant Fractal projects for our production, staging and dev environments.

name: "Fractal: Build & Deploy"

on:
    push:
        branches:
            - master
            - staging
            - dev
            - project/**
        paths-ignore:
            - "README.md"
            - "**/README.md"
            - ".github/workflows/README.md"
    workflow_dispatch:
        inputs:
            # If a specific job-name is given, then we always run exactly that job
            # If "all" is given, then we might filter jobs, it will be done as if a merge is bad to "branch-name"
            job-name:
                description: "Name of the job to trigger, or 'all' to trigger all jobs."
                required: true
                default: "" # Avoid accidental mistakes by making the default not run any jobs
            # Name of the branch to simulate merging against
            branch-name:
                description: "Branch to run the job as"
                required: true
                default: "dev"
            # If true, this will deploy the build to our infrastructure
            publish:
                description: "'true' if the job(s) being run should publish, or 'false' to do a test run without publishing."
                required: true
                default: false # Avoid accidental mistakes by making the default not publish

jobs:
    # Configure Jobs
    # Detect the branch using regex matching and store as an output to regulate downstream actions.
    # Access branch with `fractal-publish-build-config.outputs.branch`.
    fractal-publish-build-config:
        name: "Configure Jobs"
        runs-on: ubuntu-20.04
        outputs:
            branch: ${{ steps.detect-branch.outputs.branch }}
            jobs: ${{ steps.detect-jobs.outputs.jobs }}
            publish: ${{ steps.detect-publish.outputs.publish }}
            deploy_environment: ${{ steps.set-deploy-environment.outputs.deploy_environment }}
            sentry_environment: ${{ steps.set-sentry-environment.outputs.sentry_environment }}
        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  fetch-depth: 0 # Get the whole git history

            - name: Detect Branch
              id: detect-branch
              run: |
                  # Grab branch_name from workflow_dispatch inputs
                  BRANCH_NAME=${{ github.event.inputs.branch-name }}
                  if [[ -z "$BRANCH_NAME" ]]; then
                      # If no workflow_dispatch input was received, then use the git branch name
                      if [[ ${{ github.ref }} =~ ^refs/heads/master$ ]]; then
                          BRANCH_NAME=master
                      elif [[ ${{ github.ref }} =~ ^refs/heads/staging$ ]]; then
                          BRANCH_NAME=staging
                      elif [[ ${{ github.ref }} =~ ^refs/heads/dev$ ]]; then
                          BRANCH_NAME=dev
                      elif [[ ${{ github.ref }} =~ ^refs/heads/project/.*$ ]]; then
                          BRANCH_NAME=project
                      else
                          BRANCH_NAME=null
                      fi
                  fi
                  echo "branch is set to: $BRANCH_NAME"
                  echo "::set-output name=branch::$BRANCH_NAME"

            - name: Set deploy environment based on Git Branch
              id: set-deploy-environment
              run: |
                  # Grab branch_name from detect-branch
                  BRANCH_NAME=${{ steps.detect-branch.outputs.branch }}

                  if [ "$BRANCH_NAME" == "master" ]; then
                      DEPLOY_ENVIRONMENT=prod
                  elif [ "$BRANCH_NAME" == "staging" ]; then
                      DEPLOY_ENVIRONMENT=staging
                  elif [ "$BRANCH_NAME" == "dev" ]; then
                      DEPLOY_ENVIRONMENT=dev
                  else
                      DEPLOY_ENVIRONMENT=null
                  fi
                  echo "deploy_environment is set to: $DEPLOY_ENVIRONMENT"
                  echo "::set-output name=deploy_environment::$DEPLOY_ENVIRONMENT"

            - name: Set Sentry environment based on Git Branch
              id: set-sentry-environment
              run: |
                  # Grab branch_name from detect-branch
                  BRANCH_NAME=${{ steps.detect-branch.outputs.branch }}

                  # on dev branch, we don't set Sentry environment as we don't want to
                  # log to Sentry in development
                  if [ "$BRANCH_NAME" == "master" ]; then
                      SENTRY_ENVIRONMENT=prod
                  elif [ "$BRANCH_NAME" == "staging" ]; then
                      SENTRY_ENVIRONMENT=staging
                  else
                      SENTRY_ENVIRONMENT=""
                  fi
                  echo "sentry_environment is set to: $SENTRY_ENVIRONMENT"
                  echo "::set-output name=sentry_environment::$SENTRY_ENVIRONMENT"

            # This will create a "jobs" variable, containing the list of jobs to run (Each wrapped in a |)
            - name: Detect Job(s)
              id: detect-jobs
              run: |
                  # Grab branch_name from detect-branch
                  BRANCH_NAME=${{ steps.detect-branch.outputs.branch }}

                  if [[ ${{ github.event_name }} == 'push' ]]; then
                    # If this workflow was triggered by push, then we want to run all jobs
                    JOB_NAME=all
                    # Store the commit from before the push was made
                    COMPARISON_COMMIT="${{ github.event.before }}"
                  else
                    # If running from workflow_dispatch, We use the job-name given as the dispatch input
                    JOB_NAME=${{ github.event.inputs.job-name }}
                    # If running from workflow_dispatch, we compare to the branch that we're simulating a build-and-deploy against
                    COMPARISON_COMMIT="origin/$BRANCH_NAME"
                  fi

                  # Store job dependency files
                  declare -A job_dependencies
                  # If "" is given, then the whole repo will be a dependency
                  job_dependencies[container-images-publish-images-ghcr]="container-images"
                  job_dependencies[ami-publish-ec2]="ecs-host-setup ecs-host-service"
                  job_dependencies[main-webserver-deploy-heroku]="main-webserver"
                  job_dependencies[client-applications-publish-build-s3]="client-applications"
                  # Files that all jobs depend on
                  universal_dependencies=".github/workflows/fractal-build-and-deploy.yml"

                  # If the job name isn't "all", then we explicitly run exactly that job
                  if [[ "$JOB_NAME" != "all" ]]; then
                    JOB_LIST="$JOB_NAME"
                  # If JOB_NAME=all, then we do indeed run all of them if the branch is staging or master
                  elif [[ "$BRANCH_NAME" =~ "(staging|master)" ]]; then
                    JOB_LIST="${!job_dependencies[@]}"
                  # If JOB_NAME=all, and we're not merging to staging/master,
                  # then we should filter the job list based on the job's dependencies
                  else
                    JOB_LIST=""
                    for i in "${!job_dependencies[@]}"
                    do
                      DEPS="${job_dependencies[$i]}"
                      # If there are universal_dependencies, include them in the space-separated list
                      if [[ -n "$universal_dependencies" ]]; then
                        DEPS="$DEPS $universal_dependencies"
                      fi
                      # Replace spaces with |'s, to be used as "OR" in a regex path checker
                      DEPS=$(echo "$DEPS" | tr ' ' '|')
                      echo "Checking $i against $DEPS"
                      # Check if any diff'ed file starts with any of the dependency paths
                      # Final -- to distinguish commit from list of paths to diff
                      MATCH=$(git diff --name-only "$COMPARISON_COMMIT" -- | grep -E "^($DEPS)" -m 1)
                      if [[ -n "$MATCH" ]]; then
                        echo "Dependency \"$MATCH\" of job \"$i\" was changed since $COMPARISON_COMMIT"
                        JOB_LIST="$JOB_LIST $i"
                      else
                        echo "No dependency of job \"$i\" was changed"
                      fi
                      echo # Newline for easier readability
                    done
                  fi

                  echo "Jobs that have been selected to run: $JOB_LIST"
                  # Wrap jobs with |, so that "|job|" matches only that exact job (Without substring problems)
                  JOB_LIST=$(echo "|$JOB_LIST|" | tr ' ' '|')
                  echo "::set-output name=jobs::$JOB_LIST"

            - name: Detect Whether to Publish the Job(s) or Not
              id: detect-publish
              run: |
                  # if this workflow was triggered by push, then we want the jobs to publish
                  if [[ ${{ github.event_name }} == 'push' ]]; then
                    PUBLISH=true
                  else
                    # if running from workflow_dispatch, we use the github input for publishing
                    PUBLISH=${{ github.event.inputs.publish }}
                  fi

                  echo "Publish is set to: $PUBLISH"
                  echo "::set-output name=publish::$PUBLISH"

    # Container Images: Build & Publish to GitHub Container Registry
    # Build and publish the container images to a GitHub Container Registry repository
    # Runs if config succeeds and branch is in ["master", "staging", "dev"].
    container-images-publish-images-ghcr:
        name: "Container Images: Build & Publish Images to GitHub Container Registry"
        runs-on: ubuntu-20.04
        needs: [fractal-publish-build-config]
        outputs:
            task-definitions-apps-json: ${{ steps.package-matrix.outputs.task-definitions-apps-json }}
        if: >
            contains(fromJSON('["master", "staging", "dev"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(needs.fractal-publish-build-config.outputs.jobs, '|container-images-publish-images-ghcr|')
        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            - name: Configure AWS CLI # To get and install GRID driver
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
                  aws-region: us-east-1

            - name: Build release protocol # No need to run this for debug, just for release
              working-directory: protocol
              run: ./build_protocol.sh release

            - name: Walk Folder to Find All Dockerfiles and Store Paths as Environment Variable
              run: echo "apps=$(./container-images/helper-scripts/find_images_in_git_repo.sh)" >> $GITHUB_ENV

            - name: Build container images
              working-directory: container-images
              run: ./build_container_image.sh --all

            - name: Push container images
              working-directory: container-images
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  for app in ${{ env.apps }}
                  do
                    ./push_container_image.sh $app ${{ needs.fractal-publish-build-config.outputs.deploy_environment }}
                  done
              env:
                  GH_USERNAME: ${{ secrets.GHA_USERNAME }}
                  GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}

            - name: Package app names into JSON for ecs-task-definitions strategy matrices
              id: package-matrix
              run: |
                  apps_json='[]'

                  for app in ${{ env.apps }}
                  do
                    apps_json=$(echo $apps_json | jq -c ". += [\"$app\"]")
                  done

                  echo "::set-output name=task-definitions-apps-json::$apps_json"

            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":whale: Container images builds pushed to \`${{ needs.fractal-publish-build-config.outputs.deploy_environment }}\` via Docker push to GitHub Container Registry :github:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # ECS Task Definitions: Render & Deploy Task Definitions to ECS
    # Render and deploy the app task definitions to ECS.
    # Runs if config succeeds and branch is in ["master", "staging", "dev"] and publish-images-ghcr succeeds.
    ecs-task-definitions-deploy-task-definitions-ecs:
        name: "ECS Task Definitions: Render & Deploy Task Definitions to ECS"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, container-images-publish-images-ghcr]
        if: >
            contains(fromJSON('["master", "staging", "dev"]'), needs.fractal-publish-build-config.outputs.branch)

        strategy:
            matrix:
                app: ${{ fromJSON(needs.container-images-publish-images-ghcr.outputs.task-definitions-apps-json) }}
                aws-region:
                    - us-east-1
                    - us-east-2
                    - us-west-1
                    - us-west-2
                    - ca-central-1
                    - eu-west-1
                    - eu-central-1

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_ECS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_ECS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ matrix.aws-region }}

            - name: Retrieve Branch HEAD Git Hash as Env Variable
              run: echo "containers_gha_sha=$(git rev-parse HEAD)" >> $GITHUB_ENV

            - name: Store GitHub Container Registry base URI as env variable
              run: echo "ghcr_base_uri=ghcr.io" >> $GITHUB_ENV

            - name: Store taskdef name as env variable
              run: echo "taskdef_name=$(echo fractal/${{ needs.fractal-publish-build-config.outputs.deploy_environment }}/${{ matrix.app }} | tr / -)" >> $GITHUB_ENV

            - name: Generate taskdef and store JSON path to variable
              working-directory: ecs-task-definitions
              run: |
                  taskdef_json_filename=$(./generate-taskdef.sh $taskdef_name ${{ needs.fractal-publish-build-config.outputs.sentry_environment }})
                  echo "taskdef_json=ecs-task-definitions/$taskdef_json_filename" >> $GITHUB_ENV

            - name: Render Amazon ECS task Definitions
              id: render-web-container
              uses: aws-actions/amazon-ecs-render-task-definition@v1
              with:
                  container-name: fractal-container
                  task-definition: ${{ env.taskdef_json }}
                  image: ${{ env.ghcr_base_uri }}/fractal/${{ needs.fractal-publish-build-config.outputs.deploy_environment }}/${{ matrix.app }}:${{ env.containers_gha_sha }}

            - name: Deploy to Amazon ECS service
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              uses: aws-actions/amazon-ecs-deploy-task-definition@v1
              with:
                  task-definition: ${{ steps.render-web-container.outputs.task-definition }}

    # ECS Task Definitions: Notify Slack
    # Notify Slack after rendering and deploying all the task definitions.
    # Runs if deploy-task-definitions-ecs succeeds.
    ecs-task-definitions-notify-slack:
        name: "ECS Task Definitions: Notify Slack"
        needs:
            [
                fractal-publish-build-config,
                ecs-task-definitions-deploy-task-definitions-ecs,
            ]
        if: >
            success() &&
            contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
        runs-on: ubuntu-20.04
        steps:
            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":spiral_note_pad: Task Definitions rendered and deployed to ${{ needs.fractal-publish-build-config.outputs.deploy_environment }} via ECS upload :bezos:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # AMI: Build and Publish to AWS EC2
    # Build and publish the Fractal Linux AMI, containing the ECS Host Service, to all supported AWS EC2 regions.
    # Runs if config succeeds and branch is in ["master", "staging", "dev"] and publish-images-ghcr succeeds.
    ami-publish-ec2:
        name: "AMI: Build & Publish to AWS EC2"
        runs-on: ubuntu-20.04
        needs: [fractal-publish-build-config]
        if: >
            contains(fromJSON('["master", "staging", "dev"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(needs.fractal-publish-build-config.outputs.jobs, '|ami-publish-ec2|')
        env:
            aws_new_ami_source_region: us-east-1 # The AWS region our new AMI gets built in, our initial AWS supported region
            aws_new_ami_instance_type: g3.4xlarge # The AWS EC2 instance type our new AMI gets built on (must be the EC2 instance type we run in production)
            aws_new_ami_subnet_id: subnet-3341731d # The subnetwork, within the VPC, within which the EC2 instance building our new AMI runs
            aws_new_ami_vpc_id: vpc-34aded4e # The ID of the Fractal-created VPC the EC2 instance building the AMI is part of
            aws_source_ami_id: ami-0885b1f6bd170450c # The base AWS-provided AMI we build our AMI from: AWS Ubuntu Server 20.04 LTS

            # The regions our new AMI gets cloned to (should be all our other supported AWS regions)
            # defined as a formatted json array to be copied into ami_config.json directly
            aws_additional_supported_regions: "[\\\"us-east-2\\\",\\\"us-west-1\\\",\\\"us-west-2\\\",\\\"ca-central-1\\\",\\\"eu-west-1\\\",\\\"eu-central-1\\\"]"

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            ######################## Building ECS Host Service ########################

            # To build ECS Host Service
            - name: Setup Go environment
              uses: actions/setup-go@v2.1.3

            - name: Authenticate Go commands with GitHub
              run: |
                  git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/
              env:
                  GH_USERNAME: ${{ secrets.GHA_USERNAME }}
                  GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}

            - name: Build Go project
              env:
                  WEBSERVER_AUTH_SECRET_DEV: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_DEV }}
                  WEBSERVER_AUTH_SECRET_STAGING: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_STAGING }}
                  WEBSERVER_AUTH_SECRET_PROD: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_PROD }}
              working-directory: ecs-host-service
              run: make build

            ###########################################################################

            - name: Retrieve Current Git Hash as Environment Variable
              run: echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_ENV

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_EC2_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_EC2_S3_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.aws_new_ami_source_region }}

            - name: Set Appropriate GraphQL URL and Access Key (prod, staging, dev) Based on Git Branch (master, staging, dev)
              run: |
                  if [ "${GITHUB_REF##*/}" == "master" ]; then
                    echo "graphql_db_url=https://prod-database.fractal.co/v1/graphql" >> $GITHUB_ENV
                    echo "hasura_graphql_access_key=${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_PROD }}" >> $GITHUB_ENV
                    echo "webserver_url=https://prod-server.fractal.co/" >> $GITHUB_ENV
                  elif [ "${GITHUB_REF##*/}" == "staging" ]; then
                    echo "graphql_db_url=https://staging-database.fractal.co/v1/graphql" >> $GITHUB_ENV
                    echo "hasura_graphql_access_key=${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_STAGING }}" >> $GITHUB_ENV
                    echo "webserver_url=https://staging-server.fractal.co/" >> $GITHUB_ENV
                  else
                    echo "graphql_db_url=https://dev-database.fractal.co/v1/graphql" >> $GITHUB_ENV
                    echo "hasura_graphql_access_key=${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_DEV }}" >> $GITHUB_ENV
                    echo "webserver_url=https://dev-server.fractal.co/" >> $GITHUB_ENV
                  fi

            - name: Set ECS Host Service APP_ENV based on Git Branch (File gets read by ecs-host-service.service)
              working-directory: ecs-host-setup
              run: |
                  if [ "${GITHUB_REF##*/}" == "master" ]; then
                    echo 'APP_ENV=PROD' > app_env.env
                  elif [ "${GITHUB_REF##*/}" == "staging" ]; then
                    echo 'APP_ENV=STAGING' > app_env.env
                  else
                    echo 'APP_ENV=DEV' > app_env.env
                  fi

            # No quotes around ${{ env.aws_additional_supported_regions }} because ami_regions expects list.
            # Also, we write to a temp json file and move to the right one
            # because the current syntax doesn't permit modifying the same file
            # in-place via jq.
            - name: Generate ami_config.json Packer Config File for Building New AMI
              working-directory: ecs-host-setup
              run: >
                  cat ami_config.json
                  | jq -c ".builders[0].secret_key = \"${{ secrets.AWS_EC2_SECRET_ACCESS_KEY}}\""
                  | jq -c ".builders[0].access_key = \"${{ secrets.AWS_EC2_ACCESS_KEY_ID }}\""
                  | jq -c ".builders[0].ami_name = \"fractal-ecs-host-ami-${{ env.commit_sha }}-$(date +"%y%m%d%H%M%S")\""
                  | jq -c ".builders[0].region = \"${{ env.aws_new_ami_source_region }}\""
                  | jq -c ".builders[0].instance_type = \"${{ env.aws_new_ami_instance_type }}\""
                  | jq -c ".builders[0].subnet_id = \"${{ env.aws_new_ami_subnet_id }}\""
                  | jq -c ".builders[0].vpc_id = \"${{ env.aws_new_ami_vpc_id }}\""
                  | jq -c ".builders[0].source_ami = \"${{ env.aws_source_ami_id }}\""
                  | jq -c ".builders[0].ami_regions = ${{ env.aws_additional_supported_regions }}"
                  > ami_config_tmp.json
                  && mv ami_config_tmp.json
                  ami_config.json

            # This spins up an AWS EC2 instance to create the AMI, and then deletes it
            # It *could* fail if we are maxed-out in number AWS vCPUs allowed in aws_new_ami_source_region
            - name: Create New AMI in aws_new_ami_source_region via Packer, Update Region, and Update Appropriate Database
              working-directory: ecs-host-setup
              run: |
                  # Log in as Admin to get Bearer Token for Update Region API call
                  token=$(curl -X POST \
                    -H "Content-Type: application/json" \
                    --data "{ \"username\": \"${{ secrets.HEROKU_ALL_WEBSERVERS_ADMIN_USERNAME }}\", \"password\": \"${{ secrets.HEROKU_ALL_WEBSERVERS_ADMIN_PASSWORD }}\" }" \
                    "${{ env.webserver_url }}admin/login" | jq -r ".access_token")

                  # create the new AMI in aws_new_ami_source_region (region set in previous step) and copy to supported regions
                  packer -machine-readable build ami_config.json

                  # if packer fails, manifest.json does not get created and the entire workflow fails here
                  new_ami_ids=$(cat manifest.json | jq ".builds[0].artifact_id")

                  # loop through each region, replace comma with space for delimiting
                  for artifact in ${new_ami_ids//,/ }
                  do
                    ami_id=$(echo ${artifact} | grep -oE 'ami-[0-9a-z]+')
                    region=$(echo ${artifact} | grep -oE '[0-9a-z-]+:'| sed 's/.$//')

                    # update appropriate database with new AMI IDs
                    curl -X POST \
                    -H "Content-Type: application/json" \
                    -H "X-Hasura-Admin-Secret: ${{ env.hasura_graphql_access_key }}" \
                    --data "{ \"query\": \"mutation { update_hardware_region_to_ami(_set: { ami_id: \\\"${ami_id}\\\" }, where: { region_name: { _eq: \\\"${region}\\\" } }) { returning { ami_id } } }\" }" \
                    ${{ env.graphql_db_url }}

                    # run update_region on each region
                    celery_task_output_id=$(curl -X POST \
                      -H "Content-Type: application/json" \
                      -H "Authorization: Bearer ${token}" \
                      --data "{\"region_name\": \"${region}\"}" \
                      "${{ env.webserver_url }}aws_container/update_region" | jq -er ".ID") # the -e option makes jq return with error code 1 if element not found

                    # ensures update_region was called successfully
                    if [[ $? =~ 1 ]]; then
                      echo "Failed to update $region" && false
                    fi

                    # poll for update_region and its subtasks 
                    bash ../.github/workflows/helpers/ecs-host-setup/poll_webserver_update_region_celery.sh ${{ env.webserver_url}} ${celery_task_output_id} ${token}
                    if [[ $? =~ 1 ]]; then
                      echo "Failed to update $region" && false
                    fi

                  done

    # AMI: Notify Slack
    # Notify Slack after building and deploying the Fractal AMI to all supported AWS regions.
    # Runs if ami-publish-ec2 succeeds.
    ami-notify-slack:
        name: "AMI: Notify Slack"
        needs: [fractal-publish-build-config, ami-publish-ec2]
        if: >
            success() &&
            contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
        runs-on: ubuntu-20.04
        steps:
            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \"New Fractal AMI \`${{ needs.fractal-publish-build-config.outputs.branch }}\` Deployed to All Supported AWS Regions.\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # Main Webserver: Deploy to Heroku
    # Push the main-webserver subtree to the appropriate Heroku app.
    # Runs if config succeeds and branch is in ["master", "staging"] and publish-images-ghcr succeeds, or unconditionally if branch is in ["dev"] (since other workflows won't run then)
    main-webserver-deploy-heroku:
        name: "Main Webserver: Deploy to Heroku"
        runs-on: ubuntu-20.04
        needs: [fractal-publish-build-config]
        if: >
            (
              (
                contains(
                  fromJSON('["master", "staging"]'),
                  needs.fractal-publish-build-config.outputs.branch
                ) && success()
              ) ||
              (
                contains(
                  fromJSON('["dev"]'),
                  needs.fractal-publish-build-config.outputs.branch
                ) && always()
              )
            ) &&
            contains(needs.fractal-publish-build-config.outputs.jobs, '|main-webserver-deploy-heroku|')

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  fetch-depth: 0 # need to get full history for splitsh-lite

            - name: Authenticate Heroku
              run: |
                  cat > ~/.netrc << EOF
                  machine api.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  machine git.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  EOF

            - name: Add Heroku Remote
              run: |
                  if [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == dev ]]; then
                      HEROKU_APP_NAME=fractal-dev-server
                  elif [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == staging ]]; then
                      HEROKU_APP_NAME=fractal-staging-server
                  elif [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == master ]]; then
                      HEROKU_APP_NAME=fractal-prod-server
                  else
                      echo 'Error: Invalid branch' && false
                  fi
                  echo "HEROKU_APP_NAME=$HEROKU_APP_NAME" >> $GITHUB_ENV

                  heroku git:remote --app $HEROKU_APP_NAME --remote heroku-fractal-server
              env:
                  HEROKU_API_KEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}

            - name: Install splitsh-lite for Subtree Split
              run: >
                  wget -qO - https://github.com/splitsh/lite/releases/download/v1.0.1/lite_linux_amd64.tar.gz
                  | sudo tar -zxp --directory /usr/local/bin/

            - name: Split off and checkout main-webserver subtree
              run: |
                  splitsh-lite --prefix main-webserver --target refs/heads/workflows-private/main-webserver
                  git checkout workflows-private/main-webserver

            - name: Push to Heroku remote, deploying the app # force push is only necessary for the transition period, then should be removed
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: git push -f heroku-fractal-server workflows-private/main-webserver:master

            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":rocket: Webserver for branch \`${{ needs.fractal-publish-build-config.outputs.branch }}\` deployed to Heroku app \`$HEROKU_APP_NAME\` :heroku:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # Client Applications: Build & Publish to AWS S3
    # Build and publish the client applications to their respective AWS S3 bucket,
    # from which Electron-Updater pulls them for auto-updating
    # Runs if config succeeds and branch is in ["master", "staging", "dev"] and all previous publish jobs succeed
    client-applications-publish-build-s3:
        name: "Client Applications: Build & Deploy ${{ matrix.config.name }}"
        runs-on: ${{ matrix.config.os }}
        needs: [fractal-publish-build-config]
        if: >
            contains(fromJSON('["master", "staging", "dev"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(needs.fractal-publish-build-config.outputs.jobs, '|client-applications-publish-build-s3|')

        strategy:
            matrix:
                config:
                    - name: "Windows Desktop Application"
                      os: windows-2016 # cmake is pre-installed on windows-2016+ GHA machines
                    - name: "macOS Desktop Application"
                      os: macos-10.14 # cmake is pre-installed on macos-10.14+ machines

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            # Necessary for Electron to upload packaged applications to AWS S3
            - name: Configure AWS S3 CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
                  aws-region: us-east-1

            ############################# Windows Configuration Steps START #############################

            - name: Install cmake via Chocolatey on Windows GHA Machine
              if: runner.os == 'Windows'
              uses: crazy-max/ghaction-chocolatey@v1
              with:
                  args: install cmake --installargs 'ADD_CMAKE_TO_PATH=System'

            - name: Set up Visual Studio Developer Command Prompt (for nmake)
              if: runner.os == 'Windows'
              uses: ilammy/msvc-dev-cmd@v1

            ############################# Windows Configuration Steps END #############################

            ############################# Unix Configuration Steps START #############################

            - name: Install macOS Codesigning Certificates on macOS GHA Machine
              if: runner.os == 'macOS'
              uses: apple-actions/import-codesign-certs@v1
              with:
                  p12-file-base64: ${{ secrets.MACOS_SIGNING_CERTIFICATE }}
                  p12-password: ${{ secrets.MACOS_SIGNING_CERTIFICATE_PASSWORD }}

            - name: Install Linux Client Protocol Dependencies on Linux Ubuntu GHA Machines
              if: runner.os == 'Linux'
              working-directory: protocol
              run: ./setup-linux-build-environment.sh

            ############################# Unix Configuration Steps END #############################

            - name: Retrieve Desktop App Version from Config Database, Increment Minor Version, and Update Config Database Version
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              shell: bash
              run: |
                  # curl GraphQL API to retrieve version number from config database
                  curl -X POST \
                  -H 'Content-Type: application/json' \
                  -H 'X-Hasura-Admin-Secret: ${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}' \
                  --data "{ \"query\": \"query { desktop_app_version { major minor micro dev_rc staging_rc } }\" }" \
                  https://config-database.fractal.co/v1/graphql > response.json

                  # Check if we actually got back valid json. If not, we should
                  # throw a human-readable error because the config DB might be
                  # down.
                  if jq -e . > /dev/null 2>&1 <<< cat response.json ; then
                    echo "Got some valid JSON from the config DB. Continuing..."
                  else
                    echo "Failed to parse the JSON from the config DB. Is it up?" && false
                  fi

                  # parse JSON into major.minor.micro-rc
                  MAJOR=$(cat response.json | jq '.data.desktop_app_version[0].major')
                  MINOR=$(cat response.json | jq '.data.desktop_app_version[0].minor')
                  MICRO=$(cat response.json | jq '.data.desktop_app_version[0].micro')
                  DEV_RC=$(cat response.json | jq '.data.desktop_app_version[0].dev_rc')
                  STAGING_RC=$(cat response.json | jq '.data.desktop_app_version[0].staging_rc')

                  # remove temporary JSON file
                  rm -rf response.json

                  # retrieve Git commit hash for the current branch (master, staging, or dev)
                  echo "commit_hash=$(git rev-parse HEAD)" >> $GITHUB_ENV

                  # if dev or staging, increment RC by 1, else increment micro by 1 and set RC to 0
                  if [[ "${GITHUB_REF##*/}" == "master" ]]; then
                    echo 'Using master configuration...'
                    # increment version by 0.0.1
                    NEW_MICRO=$(echo "print( ${MICRO} + 1)" | python)

                    # set new desktop app version
                    NEW_VERSION="${MAJOR}.${MINOR}.${NEW_MICRO}"

                    # store NEW_MICRO in GITHUB_ENV to push to GraphQL API, and reset STAGING_RC and DEV_RC to 0
                    echo "new_micro_version=${NEW_MICRO}" >> $GITHUB_ENV
                    echo "new_staging_rc_version=0" >> $GITHUB_ENV
                    echo "new_dev_rc_version=0" >> $GITHUB_ENV

                    # curl GraphQL API to set new micro/staging_rc/dev_rc version number and git commit hash in config database
                    curl -X POST \
                    -H 'Content-Type: application/json' \
                    -H 'X-Hasura-Admin-Secret: ${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}' \
                    --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {micro: ${{ env.new_micro_version }}, staging_rc: ${{ env.new_staging_rc_version }}, dev_rc: ${{ env.new_dev_rc_version }}, prod_commit_hash: \\\"${{ env.commit_hash }}\\\"}) { id } }\" }" \
                    https://config-database.fractal.co/v1/graphql

                  elif [[ "${GITHUB_REF##*/}" == "staging" ]]; then
                    echo 'Using staging configuration...'
                    # increment version by staging-rc.1
                    NEW_STAGING_RC=$(echo "print( ${STAGING_RC} + 1)" | python)

                    # set new desktop app version
                    NEW_VERSION="${MAJOR}.${MINOR}.${MICRO}-staging-rc.${NEW_STAGING_RC}"

                    # store NEW_STAGING_RC in GITHUB_ENV to push to GraphQL API
                    echo "new_staging_rc_version=${NEW_STAGING_RC}" >> $GITHUB_ENV

                    # curl GraphQL API to set new micro/staging_rc/dev_rc version number and git commit hash in config database
                    curl -X POST \
                    -H 'Content-Type: application/json' \
                    -H 'X-Hasura-Admin-Secret: ${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}' \
                    --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {staging_rc: ${{ env.new_staging_rc_version }}, staging_commit_hash: \\\"${{ env.commit_hash }}\\\"}) { id } }\" }" \
                    https://config-database.fractal.co/v1/graphql

                  elif [[ "${GITHUB_REF##*/}" == "dev" ]]; then
                    echo 'Using dev configuration...'
                    # increment version by dev-rc.1
                    NEW_DEV_RC=$(echo "print( ${DEV_RC} + 1)" | python)

                    # set new desktop app version
                    NEW_VERSION="${MAJOR}.${MINOR}.${MICRO}-dev-rc.${NEW_DEV_RC}"

                    # store NEW_DEV_RC in GITHUB_ENV to push to GraphQL API
                    echo "new_dev_rc_version=${NEW_DEV_RC}" >> $GITHUB_ENV

                    # curl GraphQL API to set new micro/staging_rc/dev_rc version number and git commit hash in config database
                    curl -X POST \
                    -H 'Content-Type: application/json' \
                    -H 'X-Hasura-Admin-Secret: ${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}' \
                    --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {dev_rc: ${{ env.new_dev_rc_version }}, staging_commit_hash: \\\"${{ env.commit_hash }}\\\"}) { id } }\" }" \
                    https://config-database.fractal.co/v1/graphql
                  else
                    echo 'Error: Invalid branch' && false
                  fi

                  # store new desktop app version as GitHub env to substitute in client-apps package.json
                  echo "desktop_app_new_version=${NEW_VERSION}" >> $GITHUB_ENV

            - name: Select AWS S3 Bucket to Publish to Based on GHA Machine OS and Git Branch
              shell: bash
              run: |
                  if [ "$RUNNER_OS" == "Linux" ]; then
                    if [ "${GITHUB_REF##*/}" == "master" ]; then
                        echo "s3_bucket=fractal-chromium-ubuntu-prod" >> $GITHUB_ENV
                    elif [ "${GITHUB_REF##*/}" == "staging" ]; then
                        echo "s3_bucket=fractal-chromium-ubuntu-staging" >> $GITHUB_ENV
                    else
                        echo "s3_bucket=fractal-chromium-ubuntu-dev" >> $GITHUB_ENV
                    fi
                  elif [ "$RUNNER_OS" == "Windows" ]; then
                    if [ "${GITHUB_REF##*/}" == "master" ]; then
                        echo "s3_bucket=fractal-chromium-windows-prod" >> $GITHUB_ENV
                    elif [ "${GITHUB_REF##*/}" == "staging" ]; then
                        echo "s3_bucket=fractal-chromium-windows-staging" >> $GITHUB_ENV
                    else
                        echo "s3_bucket=fractal-chromium-windows-dev" >> $GITHUB_ENV
                    fi
                  else
                    if [ "${GITHUB_REF##*/}" == "master" ]; then
                        echo "s3_bucket=fractal-chromium-macos-prod" >> $GITHUB_ENV
                    elif [ "${GITHUB_REF##*/}" == "staging" ]; then
                        echo "s3_bucket=fractal-chromium-macos-staging" >> $GITHUB_ENV
                    else
                        echo "s3_bucket=fractal-chromium-macos-dev" >> $GITHUB_ENV
                    fi
                  fi

            # (builds the branch that it is run on automatically, so master if running on push to master)
            - name: Publish the Windows Electron Application
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish) && runner.os == 'Windows'
              shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
              working-directory: client-applications\desktop
              run: .\publish.bat -version=${{ env.desktop_app_new_version }} -bucket=${{ env.s3_bucket }} -env=${{ needs.fractal-publish-build-config.outputs.deploy_environment }} -publish=true

            # (builds the branch that it is run on automatically, so master if running on push to master)
            - name: Publish the macOS/Linux Ubuntu Electron Applications
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish) && runner.os == 'macOS'
              env:
                  FRACTAL_OSX_SYSROOT: "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk" # Necessary for building on macOS (protocol does NOT support 10.15+ SDKs)
              shell: bash
              working-directory: client-applications/desktop
              run: |
                  # Explicitly retrieve macOS 10.14 SDK
                  wget https://github.com/phracker/MacOSX-SDKs/releases/download/10.15/MacOSX10.14.sdk.tar.xz

                  # Untar it
                  xz -d MacOSX10.14.sdk.tar.xz
                  tar -xf MacOSX10.14.sdk.tar

                  # Move it to the right folder for building the protocol
                  mv MacOSX10.14.sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs

                  # Build the Fractal protocol and package the Electron application
                  ./publish.sh --version ${{ env.desktop_app_new_version }} --bucket ${{ env.s3_bucket }} --env ${{ needs.fractal-publish-build-config.outputs.deploy_environment }} --publish true

    # Client Applications: Notify Slack
    # Notify Slack after building and publishing the client applications for all supported OSes.
    # Runs if client-applications-publish-build-s3 succeeds.
    client-applications-notify-slack:
        name: "Client Applications: Notify Slack"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, client-applications-publish-build-s3]
        if: >
            success() &&
            contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
        steps:
            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \"Windows and macOS Electron Applications Deployed to \`${{ needs.fractal-publish-build-config.outputs.branch }}\` via Upload to AWS S3.\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}
